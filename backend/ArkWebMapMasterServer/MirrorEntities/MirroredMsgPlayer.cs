using ArkSaveEditor.Entities;
using ArkSaveEditor.Entities.LowLevel.AutoGeneratedClasses;
using ArkWebMapGatewayClient.Messages;
using ArkWebMapMasterServer.PresistEntities;
using ArkWebMapMasterServer.Tools;
using System;
using System.Collections.Generic;
using System.Text;

namespace ArkWebMapMasterServer.MirrorEntities
{
    public class MirroredMsgPlayer : MirroredMessage
    {
        public int playerId;
        public int tribeId;
        public MirroredVector3 pos;

        public override void ReadMsg(MirrorProtocolReader reader)
        {
            opcode = MirroredOpcode.Player;
            playerId = reader.ReadNextInt();
            tribeId = reader.ReadNextInt();
            pos = reader.ReadNextVector3();
        }

        public override void ProcessMsg(ArkServer s, ArkMirrorToken auth)
        {
            //Convert this position data to one for the map. First, obtain the map data
            string map = s.latest_server_map;
            ArkMapData mapinfo;
            if (ArkMapDataTable.arkmaps.ContainsKey(map))
                mapinfo = ArkMapDataTable.arkmaps[map];
            else
                return; //Cannot compute.

            //Now, convert the location here to the map data.
            Vector2 simplifedPos = new Vector2(pos.x, pos.y);
            Vector2 adjustedPos = mapinfo.ConvertFromGamePositionToNormalized(simplifedPos);

            //Create GATEWAY packet
            GatewayActionTool.SendActionToTribe(new MessageUpdateRealtimePos
            {
                updateOpcode = MessageUpdateRealtimePos.UpdateTypeOpcode.Player,
                opcode = ArkWebMapGatewayClient.GatewayMessageOpcode.RealtimeMapMovement,
                id = playerId.ToString(),

                mx = adjustedPos.x,
                my = adjustedPos.y,

                ox = pos.x,
                oy = pos.y,
                oz = pos.z
            }, tribeId, s._id);
        }
    }
}
