using ArkSaveEditor.Entities;
using ArkSaveEditor.Entities.LowLevel.AutoGeneratedClasses;
using ArkWebMapGatewayClient.Messages;
using ArkWebMapGatewayClient.Messages.Entities;
using ArkWebMapMasterServer.PresistEntities;
using ArkWebMapMasterServer.Tools;
using LibDeltaSystem.Db.System;
using System;
using System.Collections.Generic;
using System.Text;

namespace ArkWebMapMasterServer.MirrorEntities
{
    public class MirroredMsgPlayer : MirroredMessage
    {
        public int playerId;
        public int tribeId;
        public MirroredVector3 pos;
        public MirroredVector3 rotation;

        public override void ReadMsg(MirrorProtocolReader reader)
        {
            opcode = MirroredOpcode.Player;
            playerId = reader.ReadNextInt();
            tribeId = reader.ReadNextInt();
            pos = reader.ReadNextVector3();
            rotation = reader.ReadNextVector3();
        }

        public override Tuple<UpdateEntityRealtimePosition, int> ProcessMsg(DbServer s, ArkMirrorToken auth)
        {
            //Convert this position data to one for the map. First, obtain the map data
            string map = s.latest_server_map;
            ArkMapData mapinfo;
            if (ArkMapDataTable.arkmaps.ContainsKey(map))
                mapinfo = ArkMapDataTable.arkmaps[map];
            else
                return null; //Cannot compute.

            //Now, convert the location here to the map data.
            Vector2 simplifedPos = new Vector2(pos.x, pos.y);
            Vector2 adjustedPos = mapinfo.ConvertFromGamePositionToNormalized(simplifedPos);

            //Create GATEWAY packet
            return new Tuple<UpdateEntityRealtimePosition, int>(new UpdateEntityRealtimePosition
            {
                t = UpdateEntityRealtimePosition.UpdateTypeOpcode.Player,
                id = playerId.ToString(),

                mx = adjustedPos.x,
                my = adjustedPos.y
            }, tribeId);
        }
    }
}
